// identification
let NAME = "avr.BitTestInstructions"
let VERSION = "1.0"
let ARCH = "avr"
let BUILDER = "atmel"
let LICENSE = "GPL"
let COPYRIGHT = "University of Toulouse"
let YEAR = "2019"
let URL = ""

include "config.nmp"

// Bit and Bit-Test Instructions 

op LSL(d: rindex)
    syntax = format("LSL R%d", d)
    image = format("0000 11%2b %3b%1b %4b", d<4..3>, d<2..0>, d<4..4>, d<3..0>)
    action = {
        let R_ = R[d] << 1;
        SREG_C = R[d]<7..7>;
        SREG_Z = R_ == 0;
        SREG_N = R_<7..7>;
        SREG_V = SREG_N ^ SREG_C;
        SREG_S = SREG_N ^ SREG_V;
        SREG_H = R[d]<3..3>;

        R[d] = R_;
    }

op LSR(d: rindex)
    syntax = format("LSR R%d", d)
    image = format("1001 010%1b %4b 0110", d<4..4>, d<3..0>)
    action = {
        let R_ = R[d] >> 1;
        SREG_C = R[d]<0..0>;
        SREG_Z = R_ == 0;
        SREG_N = 0;
        SREG_V = SREG_N ^ SREG_C;
        SREG_S = SREG_V ^ SREG_N;

        R[d] = R_;
    }

op ROL(d: rindex)
    syntax = format("ROL R%d", d)
    image = format("0001 11%2b %3b%1b %4b", d<4..3>, d<2..0>, d<4..4>, d<3..0>)
    action = {
        let b7 = R[d]<7..7>;
        let R_ = (R[d] << 1) | SREG_C; //SREG_C is the lower bit

        SREG_C = b7;
        SREG_Z = R_ == 0;
        SREG_N = R_<7..7>;
        SREG_V = SREG_N ^ SREG_C;
        SREG_S = SREG_N ^ SREG_V;
        SREG_H = R[d]<3..3>;

        R[d] = R_;
    }

op ROR(d: rindex)
    syntax = format("ROR R%d", d)
    image = format("1001 010%1b %4b 0111", d<4..4>, d<3..0>)
    action = {
        let b0 = R[d]<0..0>;
        let R_ = (R[d] >> 1) | (SREG_C << 7); //SREG_C is to upper bit to be set in the bit7 of the result

        SREG_C = b0;
        SREG_Z = R_ == 0;
        SREG_N = R_<7..7>;
        SREG_V = SREG_N ^ SREG_C;
        SREG_S = SREG_N ^ SREG_V;

        R[d] = R_;
    }

op ASR(d: rindex)
    syntax = format("ASR R%d", d)
    image = format("1001 010%1b %4b 0101", d<4..4>, d<3..0>)
    action = {
        let bit7 = R[d]<7..7>;
        let R_ = (R[d] >> 1) | (bit7 << 7);

        SREG_C = R[d]<0..0>;
        SREG_Z = R_ == 0;
        SREG_N = R_<7..7>;
        SREG_V = SREG_C ^ SREG_N;
        SREG_S = SREG_V ^ SREG_N;

        R[d] = R_;
    }

op SWAP(d: rindex)
    syntax = format("SWAP R%d", d)
    image = format("1001 010%1b %4b 0010", d<4..4>, d<3..0>)
    action = {
        let R_ = ((R[d] & 0xF0) >> 4) | ((R[d] & 0xF) << 4);

        R[d] = R_;
    }

op BLD(d: rindex, b: card(3))
    syntax = format("BLD R%d, %d", d, b)
    image = format("1111 100%1b %4b 0%3b", d<4..4>, d<3..0>, b<2..0>)
    action = {
        R[d]<b..b> = SREG_T;
    }

op BST(d: rindex, b:card(3))
    syntax = format("BST R%d, %d", d, b)
    image = format("1111 101%1b %4b 0%3b", d<4..4>, d<3..0>, b<2..0>)
    action = {
        SREG_T = R[d]<b..b>;
    }

op BSET(s: card(3))
    syntax = format("BSET %d", s)
    image = format("1001 0100 0%3b 1000", s<2..0>)
    action = {
        SREG<s..s> = 1;
    }

op BCLR(s: card(3))
    syntax = format("BCLR %d", s)
    image = format("1001 0100 1%3b 1000", s<2..0>)
    action = {
        SREG<s..s> = 0;
    }