// identification
let NAME = "avr"
let VERSION = "1.0"
let ARCH = "avr"
let BUILDER = "atmel"
let LICENSE = "GPL"
let COPYRIGHT = "University of Toulouse"
let YEAR = "2019"
let URL = ""

//configuration
let proc = "avr"
let bit_order = "uppermost"
let gliss_isize = "32,16"

// useful types
type bit = card(1)
type byte = card(8)
type word = card(16)

// registers
reg R[32, byte]
//reg X[1, word] alias = R[27] :: R[26]
reg X[1, word] alias = R[26]
//reg Y[1, word] alias = R[29] :: R[28]
reg Y[1, word] alias = R[28]
//reg Z[1, word] alias = R[31] :: R[30]
reg Z[1, word] alias = R[30]
reg PC[1, word] pc = 1
reg SP[1, word]
reg SR[1, byte]
reg SR_I[1, bit] alias = SR<7..7>
reg SR_T[1, bit] alias = SR<6..6>
reg SR_H[1, bit] alias = SR<5..5>
reg SR_S[1, bit] alias = SR<4..4>
reg SR_V[1, bit] alias = SR<3..3>
reg SR_N[1, bit] alias = SR<2..2>
reg SR_Z[1, bit] alias = SR<1..1>
reg SR_C[1, bit] alias = SR<0..0>

// separated structure
//		flash -- 0x0000-0x3FFF
//		SRAM  -- 0x0000-0x08FF
//			32 registers			0x0000-0x001F
//			64 I/O registers 		0x0020-0x005F
//			160 Ext I/O registers	0x0060-0x00FF
//			Internal SRAM			0x0100-0x08FF
mem M[16, byte] data_memory = 1
mem M16[16, word] alias = M[0]
mem FLASH[1*6, word] program_memory = 1

type rindex = card(5)

mode reg_mode(i: rindex) = R[i]
	ii = i
	syntax = format("r%d", i)
	image = format("%5b", i)

mode reg_mode_16(i: rindex) = R[i]
	ii = i
	syntax = format("r%d", i)
	image = format("%4b", i)



op instruction(x: allinstruction)
	syntax = x.syntax
	image = x.image
	action = { x.action; }


op plus_one(x: oneinstr)
	syntax = x.syntax
	image = x.image
	action = { x.action; PC = PC + 1; }

op oneinstr = 
			ADC
		   |ADD
		   |AND
		   |ANDI
		   |ASR
		   |BCLR
		   |BLD
		   |RJMP
		   |LDS
		   |PUSH
		   |POP
		   |BREAK
		   |BSET
		   |BST
		   |CLH
		   /*|ADIW*/

op allinstruction = plus_one

op ADC(d: reg_mode, r: reg_mode)
	syntax = format("adc %s,%s",d,r)                                             //adc r2,r0
	image = format("0001 11 %1b %1b %4b %4b", r.ii<4..4>, d.ii<4..4>, d.ii<3..0>, r.ii<3..0>)    //0001 11rd dddd rrrr
	action = {
			   let R = d+r+SR_C;
			   SR_H = (d<3..3>&r<3..3>)|(r<3..3>&!R<3..3>)|(!R<3..3>&d<3..3>); 
			   SR_S = SR_N ^ SR_V; 											     
			   SR_V = (d<7..7>&r<7..7>&!d<7..7>)|(!d<7..7>&!r<7..7>&R<7..7>);
			   SR_N = R<7..7>;						     
			   SR_Z = !(R<7..7>|R<6..6>|R<5..5>|R<4..4>|R<3..3>|R<2..2>|R<1..1>|R<0..0>); 
			   SR_C = (d<7..7>&r<6..6>) | (r<7..7>&!SR<7..7>) | (!R<7..7>&d<7..7>);
			   //d=R;
			 }

op ADD(d: reg_mode, r: reg_mode)
	syntax = format("add %s,%s",d,r)                                             //adc r2,r0
	image = format("0000 11 %1b %1b %4b %4b",r.ii<4..4>,d.ii<4..4>,d.ii<3..0>,r.ii<3..0>)    //0001 11rd dddd rrrr
	action = {
			   let R=d+r+SR_C;
			   SR_H = (d<3..3>&r<3..3>)|(r<3..3>&!R<3..3>)|(!R<3..3>&d<3..3>); 
			   SR_S = SR_N ^ SR_V; 											     
			   SR_V = (d<7..7>&r<7..7>&!d<7..7>)|(!d<7..7>&!r<7..7>&R<7..7>);
			   SR_N = R<7..7>;						     
			   SR_Z = !(R<7..7>|R<6..6>|R<5..5>|R<4..4>|R<3..3>|R<2..2>|R<1..1>|R<0..0>); 
			   SR_C = (d<7..7>&r<6..6>) | (r<7..7>&!SR<7..7>) | (!R<7..7>&d<7..7>);
			   //d=R;
			 }

op ADIW(d: card(5),imm: int(5))
	syntax = format("adiw r%d:r%d,%d",d,d-1,imm)                                      
	//image = format("1001 0110 %1b %1b %4b %4b",r<4..4>,d<4..4>,d<3..0>,r<3..0>)
	action = { }

op AND(d: reg_mode, r:reg_mode)
	syntax = format("and %s,%s",d,r)
	image = format("0010 00 %1b %1b %4b %4b",,r.ii<4..4>,d.ii<4..4>,d.ii<3..0>,r.ii<3..0>)
	action = { 
			   let R=d&r;
			   SR_S = SR_N ^ SR_V; 											     
			   SR_V = 0;
			   SR_N = R<7..7>;
			   SR_Z = !(R<7..7>|R<6..6>|R<5..5>|R<4..4>|R<3..3>|R<2..2>|R<1..1>|R<0..0>);
			   //d=R;
			 }

op ANDI(d: reg_mode_16, K:card(8))
	syntax = format("andi %s, $%d", d, K)
	image = format("0111 %4b %4b %4b", K<7..4>, d.ii<4..0>, K<3..0>)
	action = {
				let R=d&K;
				SR_S = SR_N ^ SR_V; 
				SR_V = 0;
			    SR_N = R<7..7>;
			    SR_Z = !(R<7..7>|R<6..6>|R<5..5>|R<4..4>|R<3..3>|R<2..2>|R<1..1>|R<0..0>);	
	 		 }

op ASR(d: reg_mode)
	syntax = format("asr %s",d)
	image = format("1001 010 %5b 0101",d.ii<4..0>)
	action = { 
			    let R=d>>1;
				SR_S = SR_N ^ SR_V;
				SR_V =  SR_N ^ SR_C;
				SR_N = R<7..7>;
				SR_Z = !(R<7..7>|R<6..6>|R<5..5>|R<4..4>|R<3..3>|R<2..2>|R<1..1>|R<0..0>);	
				SR_C = d<0..0>;
			 }	

op BCLR(s: card(3))
	syntax = format("bclr %d",s)
	image = format("1001 0100 1%3b 1000",s<2..0>)
	action = { 
				SR<s..s> = 0;
			 }

op BLD(d: reg_mode, b:card(3))
	syntax = format("bld %s, %d", d, b)
	image = format("1111 100 %5b 0 %3b",d.ii<4..0>,b)
	action = { d<b..b>=SR_T; }

op RJMP(k:card(12))
	syntax = format("rjmp %d",k)
	image = format("1100 %12b",k<11..0>)
	action = { PC = PC + k ;}

op LDS(d: reg_mode, k:card(16))
	syntax = format("lds %s,%d",d,k)
	image = format("1001 000%5b 0000 %16b",d.ii<4..0>,k<15..0>)
	action = { PC = PC + 1 ; d=k;}

op PUSH(r: reg_mode)
	syntax = format("push %s",r)
	image = format("1001 001%5b 1111",r.ii<4..0>)
	action = {SP=r; SP=SP-1;}

op POP(r: reg_mode)
	syntax = format("pop %s",r)
	image = format("1001 000%5b 1111",r.ii<4..0>)
	action = {r=SP; SP=SP+1;}

op BREAK()
	syntax = "BREAK"
	image = "1001 0101 1001 1000"
	action = { }

op BSET(s: card(3))
	syntax = format("bset %d",s)
	image = format("1001 0100 0%3b 1000",s<2..0>)
	action = { SR<s..s> = 1; }

op BST(d:reg_mode, s: card(3))
	syntax = format("bst %s,%d",d,s)
	image = format("1111 101 %5b 0%3b",d.ii<4..0>,s<2..0>)
	action = { SR_T = d<s..s>; }


op CLH()
	syntax = "CLH"
	image = "1001 0100 1101 1000"
	action = { SR_H = 0;}